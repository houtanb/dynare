module example1Static
#
# NB: this file was automatically generated by Dynare
#     from example1.mod
#
using Utils

export static!

function static!(y::Vector{Float64}, x::Vector{Float64}, params::Vector{Float64},
                 residual::Vector{Float64})
#=
## Function Arguments

## Input
 1 y:         Array{Float64, length(model.endo), 1}             Vector of endogenous variables in declaration order
 2 x:         Array{Float64, length(model.exo), 1}              Vector of exogenous variables in declaration order
 3 params:    Array{Float64, length(model.param), 1}            Vector of parameter values in declaration order

## Output
 4 residual:  Array(Float64, model.eq_nbr, 1)                   Vector of residuals of the static model equations
                                                                in order of declaration of the equations.
                                                                Dynare may prepend auxiliary equations, see model.aux_vars
=#
  @assert length(y) == 6
  @assert length(x) == 2
  @assert length(params) == 7
  @assert length(residual) == 6
  #
  # Model equations
  #
  @inbounds const T14 = y[5]^(1+params[6])
  @inbounds const T37 = exp(y[4])*y[3]^params[3]
  @inbounds const T38 = y[5]^(1-params[3])
  @inbounds const T39 = T37*T38
  @inbounds lhs =y[2]*params[5]*T14;
  @inbounds rhs =(1-params[3])*y[1];
  @inbounds residual[1]= lhs-rhs;
  @inbounds lhs =y[3];
  @inbounds rhs =params[1]*(y[1]*params[3]*exp(y[6])+y[3]*(1-params[4]));
  @inbounds residual[2]= lhs-rhs;
  @inbounds lhs =y[1];
  @inbounds rhs =T39;
  @inbounds residual[3]= lhs-rhs;
  @inbounds lhs =y[3];
  @inbounds rhs =y[3]*(1-params[4])+exp(y[6])*(y[1]-y[2]);
  @inbounds residual[4]= lhs-rhs;
  @inbounds lhs =y[4];
  @inbounds rhs =y[4]*params[2]+y[6]*params[7]+x[1];
  @inbounds residual[5]= lhs-rhs;
  @inbounds lhs =y[6];
  @inbounds rhs =y[4]*params[7]+y[6]*params[2]+x[2];
  @inbounds residual[6]= lhs-rhs;
if ~isreal(residual)
  residual = real(residual)+imag(residual).^2;
end
end

function static!(y::Vector{Float64}, x::Vector{Float64}, params::Vector{Float64},
                 residual::Vector{Float64}, g1::Matrix{Float64})
#=
## Function Arguments

## Input
 1 y:         Array{Float64, length(model.endo), 1}             Vector of endogenous variables in declaration order
 2 x:         Array{Float64, length(model.exo), 1}              Vector of exogenous variables in declaration order
 3 params:    Array{Float64, length(model.param), 1}            Vector of parameter values in declaration order

## Output
 4 residual:  Array(Float64, model.eq_nbr, 1)                   Vector of residuals of the static model equations
                                                                in order of declaration of the equations.
                                                                Dynare may prepend auxiliary equations, see model.aux_vars
 5 g1:        Array(Float64, model.eq_nbr, length(model.endo))  Jacobian matrix of the static model equations;
                                                                columns: variables in declaration order
                                                                rows: equations in order of declaration
=#
  @assert size(g1) == (6, 6)
  fill!(g1, 0.0)
  static!(y, x, params, residual)
  #
  # Jacobian matrix
  #
  @inbounds const T14 = y[5]^(1+params[6])
  @inbounds const T37 = exp(y[4])*y[3]^params[3]
  @inbounds const T38 = y[5]^(1-params[3])
  @inbounds const T39 = T37*T38
  @inbounds g1[1,1]=(-(1-params[3]));
  @inbounds g1[1,2]=params[5]*T14;
  @inbounds g1[1,5]=y[2]*params[5]*get_power_deriv(y[5],1+params[6],1);
  @inbounds g1[2,1]=(-(params[1]*params[3]*exp(y[6])));
  @inbounds g1[2,3]=1-params[1]*(1-params[4]);
  @inbounds g1[2,6]=(-(params[1]*y[1]*params[3]*exp(y[6])));
  @inbounds g1[3,1]=1;
  @inbounds g1[3,3]=(-(T38*exp(y[4])*get_power_deriv(y[3],params[3],1)));
  @inbounds g1[3,4]=(-T39);
  @inbounds g1[3,5]=(-(T37*get_power_deriv(y[5],1-params[3],1)));
  @inbounds g1[4,1]=(-exp(y[6]));
  @inbounds g1[4,2]=exp(y[6]);
  @inbounds g1[4,3]=1-(1-params[4]);
  @inbounds g1[4,6]=(-(exp(y[6])*(y[1]-y[2])));
  @inbounds g1[5,4]=1-params[2];
  @inbounds g1[5,6]=(-params[7]);
  @inbounds g1[6,4]=(-params[7]);
  @inbounds g1[6,6]=1-params[2];
  if ~isreal(g1)
    g1 = real(g1)+2*imag(g1);
  end
end

function static!(y::Vector{Float64}, x::Vector{Float64}, params::Vector{Float64},
                 residual::Vector{Float64}, g1::Matrix{Float64}, g2::Matrix{Float64})
#=
## Function Arguments

## Input
 1 y:         Array{Float64, length(model.endo), 1}             Vector of endogenous variables in declaration order
 2 x:         Array{Float64, length(model.exo), 1}              Vector of exogenous variables in declaration order
 3 params:    Array{Float64, length(model.param), 1}            Vector of parameter values in declaration order

## Output
 4 residual:  Array(Float64, model.eq_nbr, 1)                   Vector of residuals of the static model equations
                                                                in order of declaration of the equations.
                                                                Dynare may prepend auxiliary equations, see model.aux_vars
 5 g1:        Array(Float64, model.eq_nbr, length(model.endo))  Jacobian matrix of the static model equations;
                                                                columns: variables in declaration order
                                                                rows: equations in order of declaration
 6 g2:        spzeros(model.eq_nbr, length(model.endo)^2)       Hessian matrix of the static model equations;
                                                                columns: variables in declaration order
                                                                rows: equations in order of declaration
=#
  @assert size(g2) == (6, 36)
  static!(y, x, params, residual, g1)
end

function static!(y::Vector{Float64}, x::Vector{Float64}, params::Vector{Float64},
                 residual::Vector{Float64}, g1::Matrix{Float64}, g2::Matrix{Float64},
                 g3::Matrix{Float64})
#=
## Function Arguments

## Input
 1 y:         Array{Float64, length(model.endo), 1}             Vector of endogenous variables in declaration order
 2 x:         Array{Float64, length(model.exo), 1}              Vector of exogenous variables in declaration order
 3 params:    Array{Float64, length(model.param), 1}            Vector of parameter values in declaration order

## Output
 4 residual:  Array(Float64, model.eq_nbr, 1)                   Vector of residuals of the static model equations
                                                                in order of declaration of the equations.
                                                                Dynare may prepend auxiliary equations, see model.aux_vars
 5 g1:        Array(Float64, model.eq_nbr, length(model.endo))  Jacobian matrix of the static model equations;
                                                                columns: variables in declaration order
                                                                rows: equations in order of declaration
 6 g2:        spzeros(model.eq_nbr, length(model.endo)^2)       Hessian matrix of the static model equations;
                                                                columns: variables in declaration order
                                                                rows: equations in order of declaration
 7 g3:        spzeros(model.eq_nbr, length(model.endo)^3)       Third derivatives matrix of the static model equations;
                                                                columns: variables in declaration order
                                                                rows: equations in order of declaration
=#
  @assert size(g3) == (6, 216)
  static!(y, x, params, residual, g1, g2)
end
end
