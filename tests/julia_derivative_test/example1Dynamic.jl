module example1Dynamic
#
# NB: this file was automatically generated by Dynare
#     from example1.mod
#
using Utils

export dynamic!

function dynamic!(y::Vector{Float64}, x::Matrix{Float64}, params::Vector{Float64},
                  steady_state::Vector{Float64}, it_::Int, residual::Vector{Float64})
#=
## Function Arguments

## Input
 1 y:            Array{Float64, num_dynamic_vars, 1}             Vector of endogenous variables in the order stored
                                                                 in model_.lead_lag_incidence; see the manual
 2 x:            Array{Float64, nperiods, length(model_.exo)}    Matrix of exogenous variables (in declaration order)
                                                                 for all simulation periods
 3 params:       Array{Float64, length(model_.param), 1}         Vector of parameter values in declaration order
 4 steady_state:
 5 it_:          Int                                             Time period for exogenous variables for which to evaluate the model

## Output
 6 residual:     Array(Float64, model_.eq_nbr, 1)                Vector of residuals of the dynamic model equations in
                                                                 order of declaration of the equations.
=#
  @assert length(y)+size(x, 2) == 14
  @assert length(params) == 7
  @assert length(residual) == 6
  #
  # Model equations
  #
  @inbounds const T14 = y[8]^(1+params[6])
  @inbounds const T30 = y[5]*exp(y[9])/(exp(y[12])*y[11])
  @inbounds const T37 = params[3]*exp(y[12])*y[10]+y[6]*(1-params[4])
  @inbounds const T45 = exp(y[7])*y[1]^params[3]
  @inbounds const T46 = y[8]^(1-params[3])
  @inbounds const T47 = T45*T46
  @inbounds lhs =y[5]*params[5]*T14;
  @inbounds rhs =(1-params[3])*y[4];
  @inbounds residual[1]= lhs-rhs;
  @inbounds lhs =y[6];
  @inbounds rhs =params[1]*T30*T37;
  @inbounds residual[2]= lhs-rhs;
  @inbounds lhs =y[4];
  @inbounds rhs =T47;
  @inbounds residual[3]= lhs-rhs;
  @inbounds lhs =y[6];
  @inbounds rhs =exp(y[9])*(y[4]-y[5])+(1-params[4])*y[1];
  @inbounds residual[4]= lhs-rhs;
  @inbounds lhs =y[7];
  @inbounds rhs =params[2]*y[2]+params[7]*y[3]+x[it_, 1];
  @inbounds residual[5]= lhs-rhs;
  @inbounds lhs =y[9];
  @inbounds rhs =y[2]*params[7]+params[2]*y[3]+x[it_, 2];
  @inbounds residual[6]= lhs-rhs;
end

function dynamic!(y::Vector{Float64}, x::Matrix{Float64}, params::Vector{Float64},
                  steady_state::Vector{Float64}, it_::Int, residual::Vector{Float64},
                  g1::Matrix{Float64})
#=
## Function Arguments

## Input
 1 y:            Array{Float64, num_dynamic_vars, 1}             Vector of endogenous variables in the order stored
                                                                 in model_.lead_lag_incidence; see the manual
 2 x:            Array{Float64, nperiods, length(model_.exo)}    Matrix of exogenous variables (in declaration order)
                                                                 for all simulation periods
 3 params:       Array{Float64, length(model_.param), 1}         Vector of parameter values in declaration order
 4 steady_state:
 5 it_:          Int                                             Time period for exogenous variables for which to evaluate the model

## Output
 6 residual:     Array(Float64, model_.eq_nbr, 1)                Vector of residuals of the dynamic model equations in
                                                                 order of declaration of the equations.
 7 g1:           Array(Float64, model_.eq_nbr, num_dynamic_vars) Jacobian matrix of the dynamic model equations;
                                                                 rows: equations in order of declaration
                                                                 columns: variables in order stored in model_.lead_lag_incidence
=#
  @assert size(g1) == (6, 14)
  fill!(g1, 0.0)
  dynamic!(y, x, params, steady_state, it_, residual)
  #
  # Jacobian matrix
  #
  @inbounds const T14 = y[8]^(1+params[6])
  @inbounds const T30 = y[5]*exp(y[9])/(exp(y[12])*y[11])
  @inbounds const T37 = params[3]*exp(y[12])*y[10]+y[6]*(1-params[4])
  @inbounds const T45 = exp(y[7])*y[1]^params[3]
  @inbounds const T46 = y[8]^(1-params[3])
  @inbounds const T47 = T45*T46
  @inbounds const T76 = exp(y[9])/(exp(y[12])*y[11])
  @inbounds const T82 = exp(y[12])*y[11]*exp(y[12])*y[11]
  @inbounds const T83 = (-(y[5]*exp(y[9])*exp(y[12])))/T82
  @inbounds const T88 = exp(y[7])*get_power_deriv(y[1],params[3],1)
  @inbounds const T90 = (-(T46*T88))
  @inbounds const T98 = get_power_deriv(y[8],1+params[6],1)
  @inbounds const T100 = get_power_deriv(y[8],1-params[3],1)
  @inbounds const T107 = (-(y[5]*exp(y[9])*exp(y[12])*y[11]))/T82
  @inbounds g1[1,4]=(-(1-params[3]));
  @inbounds g1[1,5]=params[5]*T14;
  @inbounds g1[1,8]=y[5]*params[5]*T98;
  @inbounds g1[2,10]=(-(params[1]*T30*params[3]*exp(y[12])));
  @inbounds g1[2,5]=(-(params[1]*T37*T76));
  @inbounds g1[2,11]=(-(params[1]*T37*T83));
  @inbounds g1[2,6]=1-params[1]*T30*(1-params[4]);
  @inbounds g1[2,9]=(-(params[1]*T30*T37));
  @inbounds g1[2,12]=(-(params[1]*(T37*T107+T30*params[3]*exp(y[12])*y[10])));
  @inbounds g1[3,4]=1;
  @inbounds g1[3,1]=T90;
  @inbounds g1[3,7]=(-T47);
  @inbounds g1[3,8]=(-(T45*T100));
  @inbounds g1[4,4]=(-exp(y[9]));
  @inbounds g1[4,5]=exp(y[9]);
  @inbounds g1[4,1]=(-(1-params[4]));
  @inbounds g1[4,6]=1;
  @inbounds g1[4,9]=(-(exp(y[9])*(y[4]-y[5])));
  @inbounds g1[5,2]=(-params[2]);
  @inbounds g1[5,7]=1;
  @inbounds g1[5,3]=(-params[7]);
  @inbounds g1[5,13]=(-1);
  @inbounds g1[6,2]=(-params[7]);
  @inbounds g1[6,3]=(-params[2]);
  @inbounds g1[6,9]=1;
  @inbounds g1[6,14]=(-1);
end

function dynamic!(y::Vector{Float64}, x::Matrix{Float64}, params::Vector{Float64},
                  steady_state::Vector{Float64}, it_::Int, residual::Vector{Float64},
                  g1::Matrix{Float64}, g2::Matrix{Float64})
#=
## Function Arguments

## Input
 1 y:            Array{Float64, num_dynamic_vars, 1}             Vector of endogenous variables in the order stored
                                                                 in model_.lead_lag_incidence; see the manual
 2 x:            Array{Float64, nperiods, length(model_.exo)}    Matrix of exogenous variables (in declaration order)
                                                                 for all simulation periods
 3 params:       Array{Float64, length(model_.param), 1}         Vector of parameter values in declaration order
 4 steady_state:
 5 it_:          Int                                             Time period for exogenous variables for which to evaluate the model

## Output
 6 residual:     Array(Float64, model_.eq_nbr, 1)                Vector of residuals of the dynamic model equations in
                                                                 order of declaration of the equations.
 7 g1:           Array(Float64, model_.eq_nbr, num_dynamic_vars) Jacobian matrix of the dynamic model equations;
                                                                 rows: equations in order of declaration
                                                                 columns: variables in order stored in model_.lead_lag_incidence
 8 g2:           spzeros(model_.eq_nbr, (num_dynamic_vars)^2)    Hessian matrix of the dynamic model equations;
                                                                 rows: equations in order of declaration
                                                                 columns: variables in order stored in model_.lead_lag_incidence
=#
  @assert size(g2) == (6, 196)
  dynamic!(y, x, params, steady_state, it_, residual, g1)
  #
  # Hessian matrix
  #
  @inbounds const T14 = y[8]^(1+params[6])
  @inbounds const T30 = y[5]*exp(y[9])/(exp(y[12])*y[11])
  @inbounds const T37 = params[3]*exp(y[12])*y[10]+y[6]*(1-params[4])
  @inbounds const T45 = exp(y[7])*y[1]^params[3]
  @inbounds const T46 = y[8]^(1-params[3])
  @inbounds const T47 = T45*T46
  @inbounds const T76 = exp(y[9])/(exp(y[12])*y[11])
  @inbounds const T82 = exp(y[12])*y[11]*exp(y[12])*y[11]
  @inbounds const T83 = (-(y[5]*exp(y[9])*exp(y[12])))/T82
  @inbounds const T88 = exp(y[7])*get_power_deriv(y[1],params[3],1)
  @inbounds const T90 = (-(T46*T88))
  @inbounds const T98 = get_power_deriv(y[8],1+params[6],1)
  @inbounds const T100 = get_power_deriv(y[8],1-params[3],1)
  @inbounds const T107 = (-(y[5]*exp(y[9])*exp(y[12])*y[11]))/T82
  @inbounds g2[1,103] = params[5]*T98
  @inbounds g2[1,64] = g2[1,103]
  @inbounds g2[1,106] = y[5]*params[5]*get_power_deriv(y[8],1+params[6],2)
  @inbounds g2[2,66] = (-(params[1]*params[3]*exp(y[12])*T76))
  @inbounds g2[2,131] = g2[2,66]
  @inbounds g2[2,150] = (-(params[1]*params[3]*exp(y[12])*T83))
  @inbounds g2[2,137] = g2[2,150]
  @inbounds g2[2,145] = (-(params[1]*T37*(-(exp(y[9])*exp(y[12])))/T82))
  @inbounds g2[2,67] = g2[2,145]
  @inbounds g2[2,151] = (-(params[1]*T37*(-((-(y[5]*exp(y[9])*exp(y[12])))*(exp(y[12])*exp(y[12])*y[11]+exp(y[12])*exp(y[12])*y[11])))/(T82*T82)))
  @inbounds g2[2,75] = (-(params[1]*(1-params[4])*T76))
  @inbounds g2[2,62] = g2[2,75]
  @inbounds g2[2,81] = (-(params[1]*(1-params[4])*T83))
  @inbounds g2[2,146] = g2[2,81]
  @inbounds g2[2,122] = (-(params[1]*T30*params[3]*exp(y[12])))
  @inbounds g2[2,135] = g2[2,122]
  @inbounds g2[2,117] = (-(params[1]*T37*T76))
  @inbounds g2[2,65] = g2[2,117]
  @inbounds g2[2,123] = (-(params[1]*T37*T83))
  @inbounds g2[2,149] = g2[2,123]
  @inbounds g2[2,118] = (-(params[1]*T30*(1-params[4])))
  @inbounds g2[2,79] = g2[2,118]
  @inbounds g2[2,121] = (-(params[1]*T30*T37))
  @inbounds g2[2,164] = (-(params[1]*(T30*params[3]*exp(y[12])+params[3]*exp(y[12])*T107)))
  @inbounds g2[2,138] = g2[2,164]
  @inbounds g2[2,159] = (-(params[1]*(T37*(-(exp(y[9])*exp(y[12])*y[11]))/T82+params[3]*exp(y[12])*y[10]*T76)))
  @inbounds g2[2,68] = g2[2,159]
  @inbounds g2[2,165] = (-(params[1]*(T37*((-(y[5]*exp(y[9])*exp(y[12])))*T82-(-(y[5]*exp(y[9])*exp(y[12])*y[11]))*(exp(y[12])*exp(y[12])*y[11]+exp(y[12])*exp(y[12])*y[11]))/(T82*T82)+params[3]*exp(y[12])*y[10]*T83)))
  @inbounds g2[2,152] = g2[2,165]
  @inbounds g2[2,160] = (-(params[1]*(1-params[4])*T107))
  @inbounds g2[2,82] = g2[2,160]
  @inbounds g2[2,163] = (-(params[1]*(T37*T107+T30*params[3]*exp(y[12])*y[10])))
  @inbounds g2[2,124] = g2[2,163]
  @inbounds g2[2,166] = (-(params[1]*(params[3]*exp(y[12])*y[10]*T107+T37*(T82*(-(y[5]*exp(y[9])*exp(y[12])*y[11]))-(-(y[5]*exp(y[9])*exp(y[12])*y[11]))*(T82+T82))/(T82*T82)+T30*params[3]*exp(y[12])*y[10]+params[3]*exp(y[12])*y[10]*T107)))
  @inbounds g2[3,1] = (-(T46*exp(y[7])*get_power_deriv(y[1],params[3],2)))
  @inbounds g2[3,85] = T90
  @inbounds g2[3,7] = g2[3,85]
  @inbounds g2[3,91] = (-T47)
  @inbounds g2[3,99] = (-(T88*T100))
  @inbounds g2[3,8] = g2[3,99]
  @inbounds g2[3,105] = (-(T45*T100))
  @inbounds g2[3,92] = g2[3,105]
  @inbounds g2[3,106] = (-(T45*get_power_deriv(y[8],1-params[3],2)))
  @inbounds g2[4,116] = (-exp(y[9]))
  @inbounds g2[4,51] = g2[4,116]
  @inbounds g2[4,117] = exp(y[9])
  @inbounds g2[4,65] = g2[4,117]
  @inbounds g2[4,121] = (-(exp(y[9])*(y[4]-y[5])))
end

function dynamic!(y::Vector{Float64}, x::Matrix{Float64}, params::Vector{Float64},
                  steady_state::Vector{Float64}, it_::Int, residual::Vector{Float64},
                  g1::Matrix{Float64}, g2::Matrix{Float64}, g3::Matrix{Float64})
#=
## Function Arguments

## Input
 1 y:            Array{Float64, num_dynamic_vars, 1}             Vector of endogenous variables in the order stored
                                                                 in model_.lead_lag_incidence; see the manual
 2 x:            Array{Float64, nperiods, length(model_.exo)}    Matrix of exogenous variables (in declaration order)
                                                                 for all simulation periods
 3 params:       Array{Float64, length(model_.param), 1}         Vector of parameter values in declaration order
 4 steady_state:
 5 it_:          Int                                             Time period for exogenous variables for which to evaluate the model

## Output
 6 residual:     Array(Float64, model_.eq_nbr, 1)                Vector of residuals of the dynamic model equations in
                                                                 order of declaration of the equations.
 7 g1:           Array(Float64, model_.eq_nbr, num_dynamic_vars) Jacobian matrix of the dynamic model equations;
                                                                 rows: equations in order of declaration
                                                                 columns: variables in order stored in model_.lead_lag_incidence
 8 g2:           spzeros(model_.eq_nbr, (num_dynamic_vars)^2)    Hessian matrix of the dynamic model equations;
                                                                 rows: equations in order of declaration
                                                                 columns: variables in order stored in model_.lead_lag_incidence
 9 g3:           spzeros(model_.eq_nbr, (num_dynamic_vars)^3)    Third order derivative matrix of the dynamic model equations;
                                                                 rows: equations in order of declaration
                                                                 columns: variables in order stored in model_.lead_lag_incidence
=#
  @assert size(g3) == (6, 2744)
  dynamic!(y, x, params, steady_state, it_, residual, g1, g2)
end
end
